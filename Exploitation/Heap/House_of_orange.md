# **House of orange**

## **Conditions**

* 공격자에 의해 Top chunk 영역에 값을 저장할 수 있어야 함
* 공격자에 의해 Top chunk의 값보다 큰 값을 생성할 수 있어야 함
* 공격자에 의해 Free chunk 영역에 값을 저장할 수 있어야 함

## **Exploit Plan**

1. Add Free chunk to Unsorted bin
    * 1개의 Heap 영역 생성
    * Top chunk 영역에 값을 덮어씀
        * Top chunk + size는 페이지 정렬
        * Top chunk 값에 prev_inuse 비트 설정
        * Ex) Top chunk : 0x20c01 -> 0xc01
    * Top chunk 영역의 값보다 큰 크기의 Heap 영역 생성
        * Malloc은 요청을 처리하기 ㅜ이해 sysmalloc 호출
        * sysmalloc()의 _int_free() 함수에 의해 "Top chunk - 0x8" 영역이 Unsorted bin에 등록
1. Write to Fake "struct _IO_FILE_plus", Fake "struct _IO_wide_data"
    * Free chunk 영역에 Fake "struct _IO_FILE_plus", Fake "struct _IO_wide_data" 구조 작성
        * Fake "struct _IO_FILE_plus"
            * _mode = '0' 보다 큰 값
            * vtable = "Fake vtable address"
            * _wide_data = Fake "struct _IO_wide_data" 저장된 주소
        * Fake "struct _IO_wide_data"
            * Fake "struct _IO_FILE_plus"가 작성된 공간을 활용
            * _IO_flush_all_lockp() 함수에서 사용하지 않는 "fp" 변수의 _freeres_list, "_freeres_buf" 영역 활용
                * fp->_freeres_list = _wide_data->_IO_write_ptr
                * fp->_freeres_buf = _wide_data->_IO_write_base
1. Unsorted bin attack
    * Free chunk의 bk 영역에 "&_IO_list_all - 0x10" 값을 덮어씀
    * Free chunk를 smallbin[4]에 등록하기 위해 Free chunk size 변경
    * 새로운 Heap 영역 생성

## **Vunlerability**

* sysmalloc()에서 _int_free() 호출하기 위해 다음 조건을 만족해야 한다.
    * Top chunk + size는 페이지 정렬되어 있어야 함
    * Top chunk 값에 prev_inuse 비트 설정되어 있어야 함


```c
// malloc.c
/*
   If not the first time through, we require old_size to be
   at least MINSIZE and to have prev_inuse set.
 */
 
assert ((old_top == initial_top (av) && old_size == 0) ||
        ((unsigned long) (old_size) >= MINSIZE &&
         prev_inuse (old_top) &&
         ((unsigned long) old_end & (pagesize - 1)) == 0));
 
/* Precondition: not enough current space to satisfy nb request */
assert ((unsigned long) (old_size) < (unsigned long) (nb + MINSIZE));
```

* glibc의 _int_malloc()에서 메모리 손상을 탐지하고 다음과 같은 순서로 함수 호출
    * _int_malloc() → malloc_printerr() → __libc_message → __FI_abort() → _IO_flush_all_lockp()

```c
// malloc.c
for (;; )
  {
    int iters = 0;
    while ((victim = unsorted_chunks (av)->bk) != unsorted_chunks (av))
      {
        bck = victim->bk;
        if (__builtin_expect (victim->size <= 2 * SIZE_SZ, 0)
            || __builtin_expect (victim->size > av->system_mem, 0))
          malloc_printerr (check_action, "malloc(): memory corruption",
                           chunk2mem (victim), av);
        size = chunksize (victim);
```

### **_IO_flush_all_lockp()**

* Top chunk와 Unsorted bin attack을 이용해 "_IO_list_all" 값을 변경하였으나, 변경된 값은 main_arena의 주소
    * 즉, "fp" 변수에 저장된 값은 main_arena의 주소이며, 해당 값을 "fp = fp->_chain" 코드에 의해 Fake "_IO_FILE_plus" 주소로 변경할 수 있다.
* _IO_flush_all_lockp() 함수는 "fp" 변수에 저장된 주소 값을 기준으로 호출할 _IO_OVERFLOW() 함수의 주소를 찾는다.

```c
// genops.c
int
_IO_flush_all_lockp (int do_lock)
{
  int result = 0;
  struct _IO_FILE *fp;
  int last_stamp;
 
#ifdef _IO_MTSAFE_IO
  __libc_cleanup_region_start (do_lock, flush_cleanup, NULL);
  if (do_lock)
    _IO_lock_lock (list_all_lock);
#endif
 
  last_stamp = _IO_list_all_stamp;
  fp = (_IO_FILE *) _IO_list_all;
  while (fp != NULL)
    {
      run_fp = fp;
      if (do_lock)
    _IO_flockfile (fp);
 
      if (((fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base)  // 해당 조건을 만족해야 "_IO_OVERFLOW()" 함수 호출 가능
#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
       || (_IO_vtable_offset (fp) == 0
           && fp->_mode > 0 && (fp->_wide_data->_IO_write_ptr
                    > fp->_wide_data->_IO_write_base))
#endif
       )
      && _IO_OVERFLOW (fp, EOF) == EOF) // 호출되는 "_IO_OVERFLOW()" 함수의 주소 값을 변경하여 system() 호출 가능
    result = EOF;
 
      if (do_lock)
    _IO_funlockfile (fp);
      run_fp = NULL;
 
      if (last_stamp != _IO_list_all_stamp)
    {
      /* Something was added to the list.  Start all over again.  */
      fp = (_IO_FILE *) _IO_list_all;
      last_stamp = _IO_list_all_stamp;
    }
      else
    fp = fp->_chain; // 해당 코드를 이용해 "fp" 변수에 Fake "_IO_FILE_plus"의 주소를 저장할 수 있다.
    }
 
#ifdef _IO_MTSAFE_IO
  if (do_lock)
    _IO_lock_unlock (list_all_lock);
  __libc_cleanup_region_end (0);
#endif
 
  return result;
}
```

* _IO_list_all 변수는 _IO_FILE_plus 구조체를 사용

```c
// libioP.h
extern struct _IO_FILE_plus *_IO_list_all;
```

* _IO_FILE_plus 구조체

```c
// libioP.h
struct _IO_FILE_plus
{
  _IO_FILE file;
  const struct _IO_jump_t *vtable;
};
```

```c
// libio.h - struct _IO_FILE
struct _IO_FILE {
  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */
#define _IO_file_flags _flags
 
  /* The following pointers correspond to the C++ streambuf protocol. */
  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
  char* _IO_read_ptr;   /* Current read pointer */
  char* _IO_read_end;   /* End of get area. */
  char* _IO_read_base;  /* Start of putback+get area. */
  char* _IO_write_base; /* Start of put area. */
  char* _IO_write_ptr;  /* Current put pointer. */
  char* _IO_write_end;  /* End of put area. */
  char* _IO_buf_base;   /* Start of reserve area. */
  char* _IO_buf_end;    /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */
 
  struct _IO_marker *_markers;
 
  struct _IO_FILE *_chain;
 
  int _fileno;
#if 0
  int _blksize;
#else
  int _flags2;
#endif
  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */
 
#define __HAVE_COLUMN /* temporary */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
 
  /*  char* _save_gptr;  char* _save_egptr; */
 
  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};
```

```c
// libioP.h - struct _IO_jump_t
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
#if 0
    get_column;
    set_column;
#endif
};
```

### **struct _IO_wide_data \*_wide_data**

```c
// genops.c
#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
       || (_IO_vtable_offset (fp) == 0
           && fp->_mode > 0 && (fp->_wide_data->_IO_write_ptr
                    > fp->_wide_data->_IO_write_base))
#endif
```

```c
// libio.h
struct _IO_wide_data *_wide_data

/* Extra data for wide character streams.  */
struct _IO_wide_data
{
  wchar_t *_IO_read_ptr;    /* Current read pointer */
  wchar_t *_IO_read_end;    /* End of get area. */
  wchar_t *_IO_read_base;   /* Start of putback+get area. */
  wchar_t *_IO_write_base;  /* Start of put area. */
  wchar_t *_IO_write_ptr;   /* Current put pointer. */
  wchar_t *_IO_write_end;   /* End of put area. */
  wchar_t *_IO_buf_base;    /* Start of reserve area. */
  wchar_t *_IO_buf_end;     /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  wchar_t *_IO_save_base;   /* Pointer to start of non-current get area. */
  wchar_t *_IO_backup_base; /* Pointer to first valid character of
                   backup area */
  wchar_t *_IO_save_end;    /* Pointer to end of non-current get area. */
 
  __mbstate_t _IO_state;
  __mbstate_t _IO_last_state;
  struct _IO_codecvt _codecvt;
 
  wchar_t _shortbuf[1];
 
  const struct _IO_jump_t *_wide_vtable;
};
```

**References**                 
<https://www.lazenca.net/display/TEC/House+of+Orange>  
<https://youngsouk-hack.tistory.com/58?category=846136>  
<https://github.com/shellphish/how2heap/blob/master/glibc_2.25/house_of_orange.c>